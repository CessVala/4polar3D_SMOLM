% =========================================================================
% Function Name: estime_intensite.m
%
% Description:
%   This function estimates the intensity of particle pairs detected in two sub-images
%   in 4polar3D data.
%
%   The function:
%     - Associates detected particles from the right and left sub-images.
%     - Uses a provided displacement to align particle positions.
%     - Handles undetected particles in one sub-image by estimating their intensity.
%
% Inputs:
%   - liste_traj: Input trajectory list.
%   - imfluo: Fluorescence image.
%   - decal_i: Displacement between right and left sub-images along the i-axis.
%   - decal_j: Displacement between right and left sub-images along the j-axis.
%   - im_i: Image used for intensity estimation (optional, required if estimating undetected particles).
%
% Outputs:
%   - liste_traj_dg: Output list of particle trajectories, organized as [right, left, right, left, ...].
%   - nb_couple_dec: Number of particle pairs successfully detected on both sides.
%   - nb_couple_est: Number of particle pairs with intensity estimation
%
% Notes:
%   - This version assumes that two separate lists of particles are provided (right and left),
%     as generated by separe_liste.m.
%   - If the geometry differs from left/right separation, separe_liste.m should be adapted.
%   - Handles cases where particles are undetected in either sub-image.
%
% Authors:
%   Nicolas Bertaux - Institut Fresnel
%   Cesar Valades-Cruz - Institute of Hydrobiology (IHB), CAS
%
% Date: December 2017
% =========================================================================

function [liste_traj_dg, nb_couple_dec, nb_couple_est] = estime_intensite(liste_traj, imfluo, decal_i, decal_j, im_i)

global nb_param_t
global param_t_i param_t_j param_t_sig2
global wn param_t_r0 param_t_alpha

flag_complete = (nargin >= 5);
flag_complete = 0;

if flag_complete
    nb_param_t = 9;
end

liste_traj_dg = [];
traj_null = [-1; zeros(nb_param_t - 1, 1)]; % num_traj == -1 for undetected particles

nb_couple_dec = 0; % Number of detected particle pairs
nb_couple_est = 0; % Number of estimated particle pairs

% Separate the trajectory list into right and left lists
vec_i = liste_traj(param_t_i, :);
vec_j = liste_traj(param_t_j, :);

[vec_d_i, vec_d_j, ind_d, vec_g_i, vec_g_j, ind_g] = separe_liste(vec_i, vec_j);

liste_traj_d = liste_traj(:, ind_d);
liste_traj_g = liste_traj(:, ind_g);

nb_traj_liste_d = size(liste_traj_d, 2);
nb_traj_liste_g = size(liste_traj_g, 2);

% Loop through all right-side particles
last_traj_d = nb_traj_liste_d;

for (ind_traj_liste_d = 1:nb_traj_liste_d)

    pos_d_i = liste_traj_d(param_t_i, ind_traj_liste_d);
    pos_d_j = liste_traj_d(param_t_j, ind_traj_liste_d);
    var_d = liste_traj_d(param_t_sig2, ind_traj_liste_d);
    r0_d = liste_traj_d(param_t_r0, ind_traj_liste_d);

    % Search for the corresponding left-side particle
    ind_g = find_traj_in_list_g(liste_traj_g, pos_d_i, pos_d_j, var_d, decal_i, decal_j);

    if (ind_g > 0)
        % Matching particle found
        liste_traj_dg = [liste_traj_dg, liste_traj_d(:, ind_traj_liste_d)];
        liste_traj_dg = [liste_traj_dg, liste_traj_g(:, ind_g)];

        % Remove matched particle from the left list
        liste_traj_g = supprime_colonne(liste_traj_g, ind_g);
        nb_traj_liste_g = nb_traj_liste_g - 1;

        nb_couple_dec = nb_couple_dec + 1;
    else
        % No matching particle found
        if (flag_complete)
            % Attempt to estimate the missing particle
            liste_traj_dg = [liste_traj_dg, liste_traj_d(:, ind_traj_liste_d)];

            traj_g = traj_null;
            traj_g(param_t_i) = pos_d_i - decal_i;
            traj_g(param_t_j) = pos_d_j - decal_j;
            traj_g(param_t_r0) = r0_d;

            traj_g(param_t_alpha) = mesure_intensite_parametres_connus(traj_g(param_t_r0), traj_g(param_t_i), traj_g(param_t_j), wn, im_i);

            liste_traj_dg = [liste_traj_dg, traj_g];
            nb_couple_est = nb_couple_est + 1;
        end
    end

    last_traj_d = ind_traj_liste_d;

    if (nb_traj_liste_g == 0)
        break;
    end
end

%% Reaches this point:
%% - Either there are remaining particles on the right and the left list is empty
%% - Or the right list is empty (last_traj_d == nb_traj_liste_d)
if (flag_complete)

    if (nb_traj_liste_g == 0)

        %% The left list is empty while there are still unpaired trajectories on the right
        for (ind_traj_liste_d = (last_traj_d + 1):nb_traj_liste_d)
            liste_traj_dg = [liste_traj_dg, liste_traj_d(:, ind_traj_liste_d)];

            pos_d_i = liste_traj_d(param_t_i, ind_traj_liste_d);
            pos_d_j = liste_traj_d(param_t_j, ind_traj_liste_d);
            r0_d = liste_traj_d(param_t_r0, ind_traj_liste_d);

            traj_g = traj_null;
            traj_g(param_t_i) = pos_d_i - decal_i;
            traj_g(param_t_j) = pos_d_j - decal_j;
            traj_g(param_t_r0) = r0_d;

            traj_g(param_t_alpha) = mesure_intensite_parametres_connus(traj_g(param_t_r0), traj_g(param_t_i), traj_g(param_t_j), wn, im_i);

            liste_traj_dg = [liste_traj_dg, traj_g];
            nb_couple_est = nb_couple_est + 1;
        end

    else
        %% There are remaining unpaired trajectories on the left
        for ind_traj_liste_g = 1:nb_traj_liste_g
            pos_g_i = liste_traj_g(param_t_i, ind_traj_liste_g);
            pos_g_j = liste_traj_g(param_t_j, ind_traj_liste_g);
            r0_g = liste_traj_g(param_t_r0, ind_traj_liste_g);

            traj_d = traj_null;
            traj_d(param_t_i) = pos_g_i + decal_i;
            traj_d(param_t_j) = pos_g_j + decal_j;
            traj_d(param_t_r0) = r0_g;

            traj_d(param_t_alpha) = mesure_intensite_parametres_connus(traj_d(param_t_r0), traj_d(param_t_i), traj_d(param_t_j), wn, im_i);

            liste_traj_dg = [liste_traj_dg, traj_d];
            liste_traj_dg = [liste_traj_dg, liste_traj_g(:, ind_traj_liste_g)];
            nb_couple_est = nb_couple_est + 1;
        end
    end
end %if (flag_complete)

end %function

%% Deletes a row from a matrix
function output = supprime_ligne(input, ind)
dim = size(input, 1);
output = [input(1:ind, :); input((ind + 1):dim, :)];
end %function

%% Deletes a column from a matrix
function output = supprime_colonne(input, ind)
dim = size(input, 2);
output = [input(:, 1:ind - 1), input(:, (ind + 1):dim)];
end %function

%% Function that searches for the most likely detected trajectory
%% corresponding to the given reference (right-side index) after translation
%% Returns the index of the left-side trajectory if it is a valid match
%% Returns 0 if no trajectory can be associated
function ind_g = find_traj_in_list_g(liste_traj_g, pos_d_i, pos_d_j, var_d, decal_i, decal_j)

global param_t_i param_t_j param_t_sig2
global r0

vec_g_i = liste_traj_g(param_t_i, :);
vec_g_j = liste_traj_g(param_t_j, :);

% Compute distances between right-side particle and all left-side particles
dist_dg_i = vec_g_i + decal_i - pos_d_i;
dist_dg_j = vec_g_j + decal_j - pos_d_j;
dist_err_dg = dist_dg_i.^2 + dist_dg_j.^2;

[err, ind_traj_g_cand] = min(dist_err_dg);

%% Test if the candidate is a valid match
%% Thresholding of dist_vec_dir
%% The threshold is applied to sqrt(b1^2 + b2^2) where b1 and b2 follow N(0, 4 * sigma^2)
%% ==> This is a Rayleigh distribution, threshold is calculated accordingly
%% Numerical thresholds:
%% Probability > 90% => threshold = 2.1 * sigma
%% Probability > 95% => threshold = 2.4 * sigma
%% Probability > 99% => threshold = 3.0 * sigma

var_g = liste_traj_g(param_t_sig2, ind_traj_g_cand);

% sqrt(err) < seuil
% seuil = 4*sqrt(var_d+var_g) ;
% seuil = 10*mean(sqrt([var_d,var_g]));
seuil = 4.* mean(sqrt([var_d, var_g]));

% Accept or reject the candidate
tv = or((sqrt(err) < seuil), (sqrt(err) < 1));

if (tv == 1)
    ind_g = ind_traj_g_cand;
else
    ind_g = 0;
end

end %function
