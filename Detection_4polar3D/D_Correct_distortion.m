% =========================================================================
% Script Name: Correct_distortion.m
%
% Description:
%   This program corrects distortions between different polarized projections 
%   in bead calibration files. It takes as input the regions selected 
%   by the 'setregions' script and performs affine registration using 
%   MATLAB's built-in registration tools.
%
% Instructions:
%   1. Select the .mat file generated by 'setregions' as input.
%   2. Use polarized projection 4 as the fixed reference projection.
%   3. Run this script three times, each time selecting a different 
%      distorted polarized projection to align to projection 4.
%   4. Check the overlay results and if satisfactory, save the calculated
%      transformation (tform) to a file.
%
% Notes:
%   - Make sure that the polarized projections are approximately pre-registered.
%   - If registration is not satisfactory, increase the number of iterations
%     and try again.
%   - In most cases, increasing iterations will improve the result.
%   - If the algorithm still struggles, check the beads file for saturated 
%     beads or extreme brightness differences, which can disrupt the 
%     registration.
%
% Tip:
%   Sometimes the registration algorithm struggles when saturated beads 
%   or highly bright and highly dim beads are present in the same frame.
%
% Authors:
%   Miguel Sison              - Institut Fresnel  
%   Cesar Valades-Cruz        - Institute of Hydrobiology (IHB), CAS
%
% Date: June 2025
% =========================================================================

%% Correct distortions in a given square
clear all
close all
clc

%% Prompt for input polarized projections and registration parameters
prompt = {'Fixed Polarized Projection:', 'Distorted Polarized Projection:', 'Maximum Iterations:'};
dlg_title = 'Correction';
num_lines = 1;
defaultans = {'4', '1', '500'};
answer = inputdlg(prompt, dlg_title, num_lines, defaultans);

%% Select the calibration file generated by 'setregions'
[filename, pathname] = uigetfile('D:\Miguel\Data\*.mat', 'Select beads file with positions');

%% Build variable names for fixed and moving polarized projections
fixedstr = ['data' answer{1} 'selcrop'];
movingstr = ['data' answer{2} 'selcrop'];

%% Load the selected regions from the file
eval(['load([pathname filename],''' fixedstr ''',''' movingstr ''');']);
fixed = evalin('base', fixedstr);
moving = evalin('base', movingstr);

%% Configure the image registration optimizer and metric
[optimizer, metric] = imregconfig('multimodal');
optimizer.InitialRadius = 0.001;
optimizer.Epsilon = 1.5e-6;
optimizer.GrowthFactor = 1.0001;
optimizer.MaximumIterations = str2double(answer{3});

%% Start registration loop
while 1
    % Perform affine registration
    tform = imregtform(moving, fixed, 'affine', optimizer, metric);
    movingRegistered = imwarp(moving, tform, 'OutputView', imref2d(size(fixed)));
    
    % Display original and registered images side by side
    figure(1)
    set(gcf, 'Color', 'w')

    subplot(1, 2, 1)
    imshowpair(fixed, moving, 'Scaling', 'joint');

    subplot(1, 2, 2)
    imshowpair(fixed, movingRegistered, 'Scaling', 'joint');
    title('Corrected')
    uiwait

    % Ask the user whether to save the transformation
    button = questdlg('Do you want to save it?');
    if (strcmp(button, 'Yes'))
        assignin('base', ['tform_' answer{1} '_' answer{2}], tform);
        uisave(['tform_' answer{1} '_' answer{2}], ['tform_' answer{1} '_' answer{2} '.mat'])
        break;
    else
        % If not satisfied, allow user to update registration parameters
        prompt = {'Initial Radius:', 'Epsilon:', 'Maximum Iterations:'};
        dlg_title = 'Correction';
        num_lines = 1;
        defaultans = {'0.001', '1.5e-6', '500'};
        answer1 = inputdlg(prompt, dlg_title, num_lines, defaultans);
        [optimizer, metric] = imregconfig('multimodal');
        optimizer.InitialRadius = str2double(answer1{1});
        optimizer.Epsilon = str2double(answer1{2});
        optimizer.GrowthFactor = 1.0001;
        optimizer.MaximumIterations = str2double(answer1{3});
    end
end
